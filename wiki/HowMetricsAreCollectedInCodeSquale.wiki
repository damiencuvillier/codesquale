#summary This page describes the mechanism of the metrics collector engine.
#labels Featured,Phase-Design

= Introduction =

CodeSquale developpement is essentially based upon the XML technology associated to the so sexy Java.

The aim of CodeSquale is to provide the end user a data file containing plenty of useful indicators and metrics build from the analysis of the desired code source. 

Let me explain you how CodeSquale works to provide these data.

First of all, let us remind what are the main steps of the code source analysis process operated by CodeSquale :

[http://codesquale.googlepages.com/FunctionnalArchitecture_Small.jpeg]

Main steps of CodeSquale processing.

1. The first step is the lexing and parsing of a selected file set of source code. ANTLR is responsible for accomplishing this vital task. ANTLR takes as input source code files and deliver as output a XML tree representative of our source code.

2. As this tree is overloaded by useless data (in sense of these data are not useful for CS), we manage to transform this tree with help of XSLT. The result of the transformation is a light XML tree represention of the code source structure. For each source file, a XML file of this type is generated. Last, a XML file describing the project hierarchy is also delivered. These files arer vital for the next step.

3. The next step is what interest us : how metrics are being collected and calculated ?

= The Metrics Collector Rngine (MCE) =

== General working ==

As described below, the step 2 (ANTLR Tree is transformed to CS Tree by XSLT) provides to the MCE a XML data file representative of a directory of a project (containing the class, attributes, methods and instructions description, and more ...).

MCE takes as input the described XML file below and delivers as output a metrics result file corresponding. See the SoftwareMetricsExplanation wiki page to see the metrics calculated. Sooner, we'll document and explain the XML generated file structure.

This process is repeated unitary for each input data file. So after, each input files have been processed : we have a set of result file representative of each package of the project providing for example number of classes, some ratios , etc...


Now, we can focus on the technical way the MCE is realized ...

== Technical specification and design ==

=== Did you say XQuery ? ===

As mentionned previously, CS strongly used XML and all around stuff. MCE component is heavily based on the XQuery langague.

*Why did we choose XQuery ?*

XQuery seems to be the right choice in the developpement of CS because we need a technology that allow to focus quickly on the functionnal specifation and avoid to spend too much time on the technical of it.

XQuery appears to us as the solution : we only have to preoccupate about the scripting of the XQ request and forgot how to execute them.

*The XQuery implementation*

The reality was slightly different of what is said below. In order to integrate XQuery in CodeSquale, we choose the SAXONB XQuery implementation. It demands us some efforts of developpment because XQ is a recent standard and there are few open source robust implementation of it.

=== Extensive and modular ===

To give us a maximun of flexibility, we set up an extensive and modular mechanism.

*The metrics collection*

CS contains an xml file which contains a list of all the metrics available in CS. These file provides these informations : 
- Short name of the metric
- Long name
- Description
- How it is collected or calculated ?
- An associated XQuery file
- The metric is enabled ?
- The return value type of the metric : atomic value (single) or a sequence (list)

This file is loaded into memory and provides the user the ability to select which final data will be collected.
Added to that, it gives the capacity to extend simply the functionnality of CodeSquale by adding element metric in the collection file and write the xquery associated.