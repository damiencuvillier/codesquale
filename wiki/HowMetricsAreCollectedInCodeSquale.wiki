#summary This page describes the mechanism of the metrics collector engine.
#labels Featured,Phase-Design

= Introduction =

CodeSquale developpement is essentially based upon the XML technology associated to the so sexy Java.

The aim of CodeSquale is to provide the end user a data file containing plenty of useful indicators and metrics build from the analysis of the desired code source. 

Let me explain you how CodeSquale works to provide this data.

First of all, let us remind what are the main steps of the code source analysis process operated by CodeSquale :

[http://codesquale.googlepages.com/FunctionnalArchitecture_Small.jpeg]

Main steps of CodeSquale processing.

1. The first step is the lexing and parsing of a selected file set of source code. ANTLR is responsible for accomplishing this vital task. ANTLR takes as input source code files and deliver as output a XML tree representative of our source code.

2. As this tree is overloaded by useless data (in sense of these data are not useful for CS), we manage to transform this tree with help of XSLT. The result of the transformation is a light XML tree represention of the code source structure. For each source file, a XML file of this type is generated. Last, a XML file describing the project hierarchy is also delivered. These files arer vital for the next step.

3. The next step is what interest us : how metrics are being collected and calculated ?

= The Metrics Collector Engine (MCE) =

== General working ==

As described below, the step 2 (ANTLR Tree is transformed to CS Tree by XSLT) provides to the MCE a XML data file representative of a directory of a project (containing the class, attributes, methods and instructions description, and more ...).

MCE takes as input the described XML file below and delivers as output a metrics result file corresponding. See the SoftwareMetricsExplanation wiki page to see the metrics calculated. Sooner, we'll document and explain the XML generated file structure.

This process is repeated unitary for each input data file. So after, each input files have been processed : we have a set of result file representative of each package of the project providing for example number of classes, some ratios , etc...


Now, we can focus on the technical way the MCE is realized ...

== Technical specification and design ==

=== Did you say XQuery ? ===

As mentionned previously, CS strongly used XML and all around stuff. MCE component is heavily based on the XQuery langague.

*Why did we choose XQuery ?*

XQuery seems to be the right choice in the developpement of CS because we need a technology that allow to focus quickly on the functionnal specifation and avoid to spend too much time on the technical of it.

XQuery appears to us as the solution : we only have to preoccupate about the scripting of the XQ request and forgot how to execute them.

*The XQuery implementation*

The reality was slightly different of what is said below. In order to integrate XQuery in CodeSquale, we choose the SAXONB XQuery implementation. It demands us some efforts of developpment because XQ is a recent standard and there are few open source robust implementation of it.

=== Extensive and modular ===

To give us a maximun of flexibility, we set up an extensive and modular mechanism.

*The metrics collection*

CS contains an xml file which contains a list of all the metrics available in CS. These file provides these informations : 
 * Short name of the metric (It is also the ID which identify the metric)
 * Long name
 * Description
 * How it is collected or calculated ?
 * An associated XQuery file
 * The metric is enabled ?
 * The return value type of the metric : atomic value (single) or a sequence (list)

Exemple of a metric element : 

{{{
<metric>
   <metricLongName>Number of others methods</metricLongName>
   <metricShortName>NOOM</metricShortName>
   <metricDescription>Total number of others methods different than public in the  project</metricDescription>
   <associatedXQueryPath>xml/XQuery/sizeMetrics/methods/noom.xquery</associatedXQueryPath>
   <enabled>true</enabled>
   <returnValueType>single</returnValueType>
</metric>
}}}

The associated XQuery file noom.xquery :
{{{
count(//directory/fileSet/file/classSet/class/methodSet/method[@modifier!="public"])
}}}

This file is loaded into memory and provides the user the ability to select which final data will be collected.
Added to that, it gives the capacity to extend simply the functionnality of CodeSquale by adding element metric in the collection file and write the xquery associated.


*The template result file*

Another capacity given to the end user is to format as it wishes the result file. A file called _MetricsResultFileConfiguration.xml_ represents the template of the result file generated by the MCE.

Section of the template
{{{
<analysisInformations>
   <packageProperties>
      <packageName>PANA</packageName>
      <packageAbsolutePath>PAPA</packageAbsolutePath>
      <numberOfFiles>NFIL</numberOfFiles>
      <weightOfFiles>WGHT</weightOfFiles>
      </packageProperties>	
</analysisInformations>
}}}

In this section, there is a set of XML tag. Theses tags encapsulates a value which is the metric ID. So the MCE can identify what metric have to be calculated for this tag.

It gives the user the abilty to modify the tag name, reorder them, and add new section with new user defined metrics. 

=== How the MCE constructs the result file ===

1. The MCE loads the metrics collection.

2. The MCE, for each XML data file generated at the step 2 of the process, will generate result file from the template result file.

 * 2.1 The input file is set as the source XML file to analyze
 * 2.2 The MCE parses the template result file
   * 2.2.1 MCE begins the construction of the result file
   * 2.2.2 For each metric ID detected in the template, the metric is processed with Xquery on the source XML file
   * 2.2.3 The returned value is appended to the result file
 * The operation is repeated as much as there is XML source files and stopped when there is no more XML source file.